package me.gamrboy4life.paradox.gui.hud;

import java.util.Collection;
import java.util.HashMap;
import java.util.Optional;

import net.minecraft.client.gui.GuiScreen;

public class HUDConfigScreen extends GuiScreen {
    private final HashMap<IRenderer, ScreenPosition> renderers = new HashMap<>();
    private Optional<IRenderer> selectedRenderer = Optional.empty();
    private int prevX, prevY;

    public HUDConfigScreen(HUDManager api) {
        Collection<IRenderer> registeredRenderers = api.getRegisteredRenderers();
        for (IRenderer ren : registeredRenderers) {
            if (!ren.isEnabled()) {
                continue;
            }

            ScreenPosition pos = ren.load();
            if (pos == null) {
                pos = ScreenPosition.fromRelativePosition(0.5, 0.5);
            }

            adjustBounds(ren, pos);
            this.renderers.put(ren, pos);
        }
    }
    
    @Override
    public void drawScreen(int mouseX, int mouseY, float partialTicks) {
        super.drawDefaultBackground();
        final float zBackup = this.zLevel;
        this.zLevel = 200;
        this.drawHollowRect(0, 0, this.width - 1, this.height - 1, 0xFFFF0000);
        
        for (IRenderer renderer : renderers.keySet()) {
            ScreenPosition pos = renderers.get(renderer);
            
            renderer.renderDummy(pos);
            this.drawHollowRect(pos.getAbsoluteX(), pos.getAbsoluteY(), renderer.getWidth(), renderer.getHeight(),0xFF00FFFF);
        }

    }
    

private void drawHollowRect(int x, int y, int w, int h, int color) { this.drawHorizontalline(x, x + w, y, color); this.drawHorizontalline(x, x + w, y + h, color);
this.drawVerticalLine(x, y + h, y, color); this.drawVerticalLine(x + w, y + h, y, color);
}
@Override
protected void keyTyped(char typedChar, int keyCode) throws IOException { Keyboard.KEY_ESCAPE) {
if (keyCode
==
renderers.entrySet().forEach((entry) -> {
entry.getKey().save(entry.getValue());
this.mc.displayGuiScreen (null);
});
}
}
@Override
protected void mouseClickMove(int x, int y, int button, long time) {
if(selectedRenderer.isPresent()) {
}
moveSelectedRenderBy(x - prevX, y
-
prevY);
this.prevX = x;
this.prevy = y;
}
}






